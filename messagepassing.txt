Sia dato un sistema di message passing asincrono con duplicazione dei messaggi.
dsnd(msg_t msg, pid_t dest)
msg_t drecv(pid_t sender)
I messaggi spediti con dsend verranno sicuramente ricevuti almeno una volta ma possono essere ricevuti più volte. È
garantita la consegna FIFO.
Implementare un sistema di message passing asincrono (classico). (non fare uso di processi server)

void asend(msg_t msg , pid_t dest){
    dsnd(msg,dest)
}

msg_t m = NULL

msg_t areceive(pid_t sender){
    msg_t msg = drecv(sender)
    if msg == m 
        return NULL
    m = msg
    return msg
}


Dato un sistema di message passing asincrono implementare un sistema di message passing asincrono
con priorità che fornisce i seguenti metodi:
pasend(int prio, msg_t msg, pid_t dest)
msg_t pasrecv(pid_t sender)
La funzione pasrecv restituisce il messaggio a massima priorità fra quelli in attesa di essere ricevuti.
(non fare uso di processi server).


let pq be a new priority queue

pasend(int prio, msg_t msg, pid_t dest){
    msg.prio = prio
    asend(msg,dest)
}

msg_t pasrecv(pid_t sender){
    msg_t msg = arecv(sender)
    pq.push(sender,msg.prio,msg)
    return pq.pop()
}


Un servizio di message passing asincrono esteso (XAMP) fornisce 4 chiamate:
• void xsend(msg_t msg, pid_t pid): spedisce il messaggio msg al processo pid
• msg_t xrecv(pid_t pid): riceve un messaggio da pid (o da chiuque se pid==0). E' una receive completamente
asincrona: se non c'è nessun messaggio da pid (o da chiunque se pid==0), xrecv restituisce NULL, non attende.
• int xcount(pid_t pid): ritorna il numero di messaggi in attesa di essere ricevuti provenienti da pid (o da
chiunque se pid==0).
• void xexpect(pid_t pid): attende che vi sia almeno un messaggio in attesa di essere ricevuto proveniente da
pid (o da chiunque se pid==0). Se un tale elemento esiste al momento della chiamata, xexpect non è
bloccante.
Il servizio XAMP ha lo stesso potere espressivo del message passing asincrono? (quello definito a lezione)


