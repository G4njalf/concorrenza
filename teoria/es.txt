# Scrivere il monitor delay che fornisce due procedure entry:
# int wait_tick(int nticks)
# void tick(void)
# La procedure entry tick è pensata per essere richiamata periodicamente (es. ogni secondo o ora o giorno) da un
# processo.
# Quando un processo chiama la wait_tick deve attendere un numero di chiamate della tick pari al parametro nticks.
# Per esempio se un processo chiama wait_tick(2) deve fermarsi e verrà riattivato alla seconda successiva chiamata di
# tick.
# La funzione wait_tick ha come valore di ritorno il numero di processi che erano bloccati al momento della tick che ha
# sbloccato il chiamante.
# Esempio: P chiama wait_tick(2) e si blocca. Q chiama wait_tick(3) e si blocca. T chiama tick() non succede nulla. R
# chiama wait_tick(2) e si blocca. T chiama tick(), viene sbloccata la wait_tick di P e il valore ritornato è 3. T chiama
# tick(), vengono sbloccate le wait_tick di Q e R e il valore ritornato per entrambi i processi è 2

class delay(monitor.monitor):
    def __init__(self):
        super().__init__()
        self.counter = 0
        self.mem = 0
        self.wait1 = monitor.condition(self)
        self.nticks = [] 
        self.sawticks = []

    @monitor.entry
    def wait_tick(self,nticks):
        self.counter += 1
        self.nticks.append(nticks)
        self.sawticks.append(0)
        self.wait1.wait()
        return self.mem
        


    @monitor.entry
    def tick(self):
        self.mem = self.counter
        j = 0
        for j in range(len(self.sawticks)):
            self.sawticks[j] += 1
        lung = len(self.nticks)
        for _ in range(lung):
            if self.sawticks[0] == self.nticks[0]:
                self.counter -= 1
                self.sawticks.remove(self.sawticks[0])
                self.nticks.remove(self.nticks[0])
                lung -= 1
                self.wait1.signal()